/* tslint:disable */
/* eslint-disable */
/**
 * NKM RTD CampaignEditor API
 * <h5>UI handler and the main responsibility carrier of the application, the two step transaction handling owner. The API defines the public interface for the UI and all the user exposed functions are routed here. The actual methods are supports basic segmentation creation and CSV upload functionality. CSV upload is supported via sharepoint. Authentication and JWT token are generated here from <b>Active Directory</b> login. The substraction of public api descriptions are on the API descriptions.</h5>
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    CreateSegmentationFromCsvCommand,
    CreateSegmentationFromCsvCommandFromJSON,
    CreateSegmentationFromCsvCommandToJSON,
    CreateUpdateSegmentationCommand,
    CreateUpdateSegmentationCommandFromJSON,
    CreateUpdateSegmentationCommandToJSON,
    DiscountSegmentVm,
    DiscountSegmentVmFromJSON,
    DiscountSegmentVmToJSON,
    OrderByType,
    OrderByTypeFromJSON,
    OrderByTypeToJSON,
    SegmentListItemVmPaginatedSearchResponse,
    SegmentListItemVmPaginatedSearchResponseFromJSON,
    SegmentListItemVmPaginatedSearchResponseToJSON,
    SegmentationType,
    SegmentationTypeFromJSON,
    SegmentationTypeToJSON,
    SegmentationVm,
    SegmentationVmFromJSON,
    SegmentationVmToJSON,
} from '../models';

export interface CreateFromCsvRequest {
    createSegmentationFromCsvCommand?: CreateSegmentationFromCsvCommand;
}

export interface CreateSegmentationRequest {
    createUpdateSegmentationCommand?: CreateUpdateSegmentationCommand;
}

export interface DownloadBusinessPartnersRequest {
    id: number;
}

export interface GetDiscountSegmentationRequest {
    id: number;
}

export interface GetSegmentationRequest {
    id: number;
}

export interface GetSegmentationsRequest {
    name?: string;
    createdDateFrom?: string;
    createdDateTo?: string;
    categoryName?: string;
    segmentationCategoryId?: number;
    type?: SegmentationType;
    skip?: number;
    take?: number;
    orderBy?: string;
    ids?: Array<number>;
    page?: number;
    pageSize?: number;
    orderByType?: OrderByType;
}

export interface UpdateSegmentationRequest {
    createUpdateSegmentationCommand?: CreateUpdateSegmentationCommand;
}

export interface UploadCsvForSegmentationRequest {
    file?: Blob;
}

/**
 * no description
 */
export class SegmentationsApi extends runtime.BaseAPI {

    /**
     * These partners are different than others, has to be different id\'s as well,   although they will act like a normal segment partners and can have problems   during matching request from EDE
     * Create a CSV like segment with the given partners.
     */
    async createFromCsvRaw(requestParameters: CreateFromCsvRequest): Promise<runtime.ApiResponse<number>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/api/Segmentations/CreateFromCsv`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateSegmentationFromCsvCommandToJSON(requestParameters.createSegmentationFromCsvCommand),
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * These partners are different than others, has to be different id\'s as well,   although they will act like a normal segment partners and can have problems   during matching request from EDE
     * Create a CSV like segment with the given partners.
     */
    async createFromCsv(requestParameters: CreateFromCsvRequest): Promise<number> {
        const response = await this.createFromCsvRaw(requestParameters);
        return await response.value();
    }

    /**
     * Creates the dedicates segmentation. The creation will results in an identification,  assigned to the current instance.
     */
    async createSegmentationRaw(requestParameters: CreateSegmentationRequest): Promise<runtime.ApiResponse<void>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/api/Segmentations/Create`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateUpdateSegmentationCommandToJSON(requestParameters.createUpdateSegmentationCommand),
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Creates the dedicates segmentation. The creation will results in an identification,  assigned to the current instance.
     */
    async createSegmentation(requestParameters: CreateSegmentationRequest): Promise<void> {
        await this.createSegmentationRaw(requestParameters);
    }

    /**
     * TODO: Investigation these to where to refact. Where they are used exactly?
     * Downloads the partners who were contracted in this segmentation.
     */
    async downloadBusinessPartnersRaw(requestParameters: DownloadBusinessPartnersRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling downloadBusinessPartners.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/api/Segmentations/DownloadBusinessPartners/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * TODO: Investigation these to where to refact. Where they are used exactly?
     * Downloads the partners who were contracted in this segmentation.
     */
    async downloadBusinessPartners(requestParameters: DownloadBusinessPartnersRequest): Promise<void> {
        await this.downloadBusinessPartnersRaw(requestParameters);
    }

    /**
     * Get the connected discound based on the id identifier.
     */
    async getDiscountSegmentationRaw(requestParameters: GetDiscountSegmentationRequest): Promise<runtime.ApiResponse<DiscountSegmentVm>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getDiscountSegmentation.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/api/Segmentations/GetDiscountSegmentationById/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => DiscountSegmentVmFromJSON(jsonValue));
    }

    /**
     * Get the connected discound based on the id identifier.
     */
    async getDiscountSegmentation(requestParameters: GetDiscountSegmentationRequest): Promise<DiscountSegmentVm> {
        const response = await this.getDiscountSegmentationRaw(requestParameters);
        return await response.value();
    }

    /**
     * Gets the requested segmentation, identified by id.
     */
    async getSegmentationRaw(requestParameters: GetSegmentationRequest): Promise<runtime.ApiResponse<SegmentationVm>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getSegmentation.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/api/Segmentations/Get/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => SegmentationVmFromJSON(jsonValue));
    }

    /**
     * Gets the requested segmentation, identified by id.
     */
    async getSegmentation(requestParameters: GetSegmentationRequest): Promise<SegmentationVm> {
        const response = await this.getSegmentationRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns the segmentation for the actual query.
     */
    async getSegmentationsRaw(requestParameters: GetSegmentationsRequest): Promise<runtime.ApiResponse<SegmentListItemVmPaginatedSearchResponse>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.name !== undefined) {
            queryParameters['Name'] = requestParameters.name;
        }

        if (requestParameters.createdDateFrom !== undefined) {
            queryParameters['CreatedDateFrom'] = requestParameters.createdDateFrom;
        }

        if (requestParameters.createdDateTo !== undefined) {
            queryParameters['CreatedDateTo'] = requestParameters.createdDateTo;
        }

        if (requestParameters.categoryName !== undefined) {
            queryParameters['CategoryName'] = requestParameters.categoryName;
        }

        if (requestParameters.segmentationCategoryId !== undefined) {
            queryParameters['SegmentationCategoryId'] = requestParameters.segmentationCategoryId;
        }

        if (requestParameters.type !== undefined) {
            queryParameters['Type'] = requestParameters.type;
        }

        if (requestParameters.skip !== undefined) {
            queryParameters['Skip'] = requestParameters.skip;
        }

        if (requestParameters.take !== undefined) {
            queryParameters['Take'] = requestParameters.take;
        }

        if (requestParameters.orderBy !== undefined) {
            queryParameters['OrderBy'] = requestParameters.orderBy;
        }

        if (requestParameters.ids) {
            queryParameters['Ids'] = requestParameters.ids;
        }

        if (requestParameters.page !== undefined) {
            queryParameters['Page'] = requestParameters.page;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['PageSize'] = requestParameters.pageSize;
        }

        if (requestParameters.orderByType !== undefined) {
            queryParameters['OrderByType'] = requestParameters.orderByType;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/api/Segmentations/Get`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => SegmentListItemVmPaginatedSearchResponseFromJSON(jsonValue));
    }

    /**
     * Returns the segmentation for the actual query.
     */
    async getSegmentations(requestParameters: GetSegmentationsRequest): Promise<SegmentListItemVmPaginatedSearchResponse> {
        const response = await this.getSegmentationsRaw(requestParameters);
        return await response.value();
    }

    /**
     * The endpoint basic results in Microsoft.AspNetCore.Mvc.NoContentResult. If the process mechanism was  failed for some reason the result is NKM.RTD.CampaignEditor.Prototypes.ErrorContract.
     * Update the current instance with the fulfilled model
     */
    async updateSegmentationRaw(requestParameters: UpdateSegmentationRequest): Promise<runtime.ApiResponse<void>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/api/Segmentations/Update`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateUpdateSegmentationCommandToJSON(requestParameters.createUpdateSegmentationCommand),
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * The endpoint basic results in Microsoft.AspNetCore.Mvc.NoContentResult. If the process mechanism was  failed for some reason the result is NKM.RTD.CampaignEditor.Prototypes.ErrorContract.
     * Update the current instance with the fulfilled model
     */
    async updateSegmentation(requestParameters: UpdateSegmentationRequest): Promise<void> {
        await this.updateSegmentationRaw(requestParameters);
    }

    /**
     * These partners are different than others, has to be different id\'s as well,   although they will act like a normal segment partners and can have problems   during matching request from EDE
     * Upload a CSV segment which will act like a normal segmentation.
     */
    async uploadCsvForSegmentationRaw(requestParameters: UploadCsvForSegmentationRequest): Promise<runtime.ApiResponse<number>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters.file !== undefined) {
            formParams.append('file', requestParameters.file as any);
        }

        const response = await this.request({
            path: `/api/Segmentations/UploadCsv`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * These partners are different than others, has to be different id\'s as well,   although they will act like a normal segment partners and can have problems   during matching request from EDE
     * Upload a CSV segment which will act like a normal segmentation.
     */
    async uploadCsvForSegmentation(requestParameters: UploadCsvForSegmentationRequest): Promise<number> {
        const response = await this.uploadCsvForSegmentationRaw(requestParameters);
        return await response.value();
    }

}
